#!/usr/bin/python

# libneterpreter - interactive libnet interpreter
# Copyright (C) 2011 Nadeem Douba
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Nadeem Douba <ndouba at gmail dot com>
# 348 Patricia Ave, Ottawa, ON, K1Z 6G6
# Canada

import sys

from code import InteractiveConsole

import libnet
from libnet.constants import *

import rlcompleter
import readline

import argparse

def parseargs(argv):

	tmp = []

	for i in argv:
		tmp.extend(i.split(' '))

	parser = argparse.ArgumentParser(description='Interactive Libnet Interpretter - Copyright (C) 2011 Nadeem Douba under GNU GPL.')
	parser.add_argument('script', metavar='script', type=str, nargs='?', help='a libneterpretter script (e.g. script.libnet).', default=None)
	parser.add_argument('-i', metavar='<device>', required=True, help='the packet injection interface (e.g. eth0).', default=None)
	parser.add_argument('-t', metavar='<injection_type>', help='the injection type. Can be either RAW4, RAW4_ADV, RAW6, RAW6_ADV, LINK, or LINK_ADV', default='RAW4', choices=('RAW4', 'RAW4_ADV', 'RAW6', 'RAW6_ADV', 'LINK', 'LINK_ADV'))
	args = parser.parse_args(tmp)

	return args.i, args.t, args.script
	

def main(argv, locals=None):

	device, injection_type, script = parseargs(argv)
	
	# evaluate injection type name to integer
	injection_type = eval(injection_type)

	# Setup readline for easy function reference
	readline.parse_and_bind("tab: complete")

	# Initialize libnet context
	try:
		c = libnet.context(device=device, injection_type=injection_type)
	except libnet.error as err:
		print(err)
		sys.exit(-1)

	# Create some easy aliases for everything
	for i in dir(c):
		if i.startswith('build_'):
			locals[i.replace('build_','',1)] = eval('c.%s' % i)
		elif i.startswith('autobuild_'):
			locals[i.replace('build','',1)] = eval('c.%s' % i)
		elif i.startswith('get'):
			locals[i.replace('get','',1)] = eval('c.%s' % i)
		elif i.startswith('diag_'):
			locals[i.replace('diag_','',1)] = eval('c.%s' % i)
		if i.startswith('__') == False:
			locals[i] = eval('c.%s' % i)

	shell = LibnetShell(locals=locals)

	if script:
		shell.runsource(file(script).read(), symbol='exec')
	else:
		shell.interact(banner='Welcome to the libnet interactive console.\nCopyright (C) 2011 Nadeem Douba under GNU GPL\n')

class LibnetShell(InteractiveConsole):

	def __init__(self, locals=None):
		InteractiveConsole.__init__(self, locals=locals)

	def raw_input(self, prompt):
		line = InteractiveConsole.raw_input(self, prompt="libnet> ")

		if line.lower() == 'help':
			return 'help(libnet)'

		if line.lower() == 'diag':
			self.push('print "\\nLibnet Context State:\\n------------------------"')
			self.push('dump_context()')
			self.push('print "\\nPacket Stats:\\n------------------------"')
			self.push('stats()')
			self.push('print "\\nCurrent Packet (decoded):\\n------------------------"')
			self.push('print packet()')
			return 'print'

		if self.locals.has_key(line) and hasattr(self.locals[line], '__call__'):
			return '%s()' % line

		return line

if __name__ == '__main__':

	main(sys.argv[1:], locals())
